name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build-and-test:
    name: Build & Unit Tests
    runs-on: ubuntu-latest

    steps:
      # 1️⃣ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2️⃣ Cache Bun runtime
      - name: Cache Bun
        uses: actions/cache@v3
        with:
          path: ~/.bun
          key: bun-${{ runner.os }}-${{ hashFiles('bun.lock') }}

      # 3️⃣ Install Bun
      - name: Install Bun
        run: |
          curl -fsSL https://bun.sh/install | BUN_INSTALL_VERSION=1.9.0 bash
          echo "$HOME/.bun/bin" >> $GITHUB_PATH

      # 4️⃣ Install dependencies
      - name: Install dependencies
        run: bun install
      - name: Reinstall @prisma/client
        run: bun add @prisma/client

      # 5️⃣ Build the app
      - name: Build app
        run: bun run build:stage

      # 6️⃣ Check code format
      - name: Check code format
        run: npx prettier --check src/**/*.ts

      # 7️⃣ Lint
      - name: Run ESLint
        run: bun run lint

      # 8️⃣ Generate Prisma client
      - name: Generate Prisma client
        run: bunx prisma generate

      # 9️⃣ Run unit tests
      - name: Run unit tests
        run: bun run test:unit

  integration-tests:
    name: Run Integration Tests in Docker
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
      # 1️⃣ Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2️⃣ Create .env from the secret
      - name: Create .env
        run: printf "%s\n" "${{ secrets.ENV }}" > .env

      # 3️⃣ Start containers, wait for DB, apply migrations & seed and prepare node enviroment for Vitest
      - name: Set up Docker Compose
        env:
          DATABASE_URL: postgresql://dart:${{ secrets.POSTGRES_PASSWORD }}@db:5432/postgresdb
          POSTGRES_USER: dart
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB: postgresdb
          PORT: 3000
        run: docker compose --profile test up --build -d

      - name: Wait for PostgreSQL
        run: |
          ATTEMPTS=0
          MAX_ATTEMPTS=15
          until docker compose exec -T db pg_isready -U dart > /dev/null 2>&1; do
            echo "Waiting for database..."
            sleep 2
            ATTEMPTS=$((ATTEMPTS+1))
            if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
              echo "Database did not become ready in time."
              exit 1
            fi
          done

      - name: Apply migrations, generate Prisma client & seed
        run: |
          docker compose exec -T app4 bunx prisma migrate deploy
          docker compose exec -T app4 bunx prisma generate
          docker compose exec -T app4 bunx prisma db seed

      # 4️⃣ Run tests (coverage)
      - name: Run tests (unit & integration)
        run: docker compose exec -T app4 bun run test:coverage
      # 5️⃣ Tear down Docker containers
      - name: Tear down containers
        run: docker compose down --volumes --remove-orphans

      # 6️⃣ Clean up the .env file
      - name: Cleanup .env
        run: rm -f .env

  build-and-push-image:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: integration-tests

    steps:
      # 1️⃣ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2️⃣ Cache Bun runtime
      - name: Cache Bun
        uses: actions/cache@v3
        with:
          path: ~/.bun
          key: bun-${{ runner.os }}-${{ hashFiles('bun.lock') }}

      # 3️⃣ Install Bun
      - name: Install Bun
        run: |
          curl -fsSL https://bun.sh/install | BUN_INSTALL_VERSION=1.9.0 bash
          echo "$HOME/.bun/bin" >> $GITHUB_PATH

      # 4️⃣ Login to DockerHub
      - name: Log in to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 1️⃣ Create .env from the secret
      - name: Create .env
        run: printf "%s\n" "${{ secrets.ENV }}" > .env

      # 5️⃣ Build Docker image
      - name: Build Docker image
        run: docker build --build-arg ENV_FILE=.env -t dartw/virtus-backend:${{ github.sha }} .

      # 6️⃣ Tag image as dev
      - name: Tag image
        run: docker tag dartw/virtus-backend:${{ github.sha }} dartw/virtus-backend:dev

      # 7️⃣ Push Docker images
      - name: Push Docker images
        run: docker push dartw/virtus-backend:${{ github.sha }} && docker push dartw/virtus-backend:dev

      - name: Cleanup .env
        run: rm -f .env

  deploy-stage:
    name: Deploy to Stage
    runs-on: ubuntu-latest
    needs: build-and-push-image

    steps:
      # 1️⃣ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v3

      # 2️⃣ Install Fly CLI
      - name: Install Flyctl
        run: |
          curl -L https://fly.io/install.sh | sh
          echo "$HOME/.fly/bin" >> $GITHUB_PATH

      # 3️⃣ Login to Fly.io
      - name: Fly login using token
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN_VIRTUS_BACKEND }}
        run: flyctl auth token

      # 4️⃣ Deploy Docker image to Fly.io stage
      - name: Deploy to stage
        env:
          FLY_API_TOKEN: ${{ secrets.FLY_API_TOKEN_VIRTUS_BACKEND }}
        run: |
          flyctl deploy \
            --app my-app-stage \
            --image dartw/virtus-backend:dev \
            --region gru \
            --strategy immediate

      # 5️⃣ Optional: wait a few seconds for the app to become healthy
      - name: Wait for app
        run: sleep 10

      # 6️⃣ Run stage smoke tests (optional)
      - name: Run stage smoke tests
        run: |
          curl -f https://api.my-app.fly/health || exit 1
